# Technologie-Stack

Mein Tech-Stack sowie die jeweilige Begründung.

Primär-Ziel meines Stacks ist die Entwicklung nachhaltiger webbasierter Geschäftsanwendungen.
Mein Stack ist auf Windows-Entwicklung ausgerichtet, auch wenn sich das dank der neuen Ausrichtungen von Microsoft Schritt für Schritt immer mehr ändert. Ursache ist hierbei die Anpassung an meinen Arbeitgeber, der als Microsoft-Partner eben solche Produkte und damit vornehmlich Windows einsetzt.

Es gibt immer mal wieder Projekte, die nicht in diesen Bereich fallen, dafür gibt es sekundäre Technologien im Stack, die ich mit * gekennzeichnet habe.

## Programmiersprachen

### HTML, CSS + Javascript

  - das Frontend-Set. Hier geht es darum hübsche und funktionale Weboberflächen gestalten zu können, die man sonst nicht hätte. 

### ASP.Net 

  - Gehört dazu, wenn man in .Net Webanwendungen bauen will. Es ist nicht schlecht, aber mir fehlt der Vergleich um den Charakter zu beschreiben.
  - Es ist komfortabler als PHP und nutzt natürlich den Compiler mit.

### C# 

  - ist sehr produktiv. Durch den Einsatz des Compilers und die vorteilhafte Orientierung des Frameworks kann man Geschäftsanwendungen ohne viel Drumrum bauen. 
  - Es ist im Vergleich zu C++ komfortabler. 
  - Man kann ob der Reflection sehr gut Unit Tests integrieren oder auch Formen von Meta-Programmierung nutzen
  - Keine direkte Kontrolle über Speicher, aber hier geht es auch darum, schnell Arbeit wegzuschaffen und auf Dauer wartbar zu bleiben.

### PHP*

  - PHP hat eigentlich nur den Vorteil, das Hosting-Platz überall verfügbar ist. Der Rest ist Kuddelmuddel.

  
### MySQL*

  - wird einem überall hinterhergeworfen. Es ist nicht schön, aber zuverlässig und umsonst. 
  - Insbesondere das es vergisst, wie ein View oder eine Stored Procedure im Source aussehen, sobald die erstellt sind, ist ein fieser Nachteil. Bei Performance bin ich mir nicht mal sicher. Das müsste man von Fall zu Fall entscheiden.


### Powershell*

  - fügt meinem Set eine Batch-Sprache hinzu, mit der man in Windows gut automatisieren kann. Es sind zunehmend für Server-Produkte lauter Schnittstellen verfügbar. 

### SQL Server 

  - ist eine gute, erweiterbare DB-Engine, die unter anderem nicht vergisst, wie der Source von einmal erstellten SQL Objekten aussieht. Mit ein paar Erweiterungen hier und da und einer Volltextsuche über alle Objekte in der DB sowie einem Tool, dass die Inhalte der DB in einem Source Versionierungstool hinterlegt bin ich sehr zufrieden. 

### C++*

  - es ermöglicht ohne Zwischenschichten direkt mit dem Betriebssystem zu interagieren
  - die Geschwindigkeit ist sehr gut und die Präzision von z.B. Speicheroperationen. D.h. sie ermöglicht ein hohes Maß an Kontrolle. 
  - es sperrt mich nicht auf ein .Net Framework ein, wenn ich mal nicht darauf hoffen kann, zu wissen welches denn verfügbar ist.
  - Negativ: Aber es ist auch schlimm, wenn man schnell viel schaffen will. Dann bringen einen die vielen Details um den Nerv. Jedenfalls mich noch. Ich bin ja hier noch totaler Anfänger.

### R (wird wieder abgezogen)

  - R hat diverse Vorteile in der Verarbeitung von Massen-Daten. Auf der anderen Seite setze ich es so selten ein, dass ich glaube, dass ich es von allen Sprachen im Stack am ehesten entbehren kann.
  
## Tools, Bibliotheken und Paradigmen

  - Knockout.js (komplexere Frontends)
  - jQuery (simple Frontends)
  - SASS (SCSS)
  - CSS BEM
  - SQL Server Management Studio
  - Windows Server 2012 R2
  - Windows 10
  - Visual Studio 2017
  - Git
  - Mercurial
  - nodejs
  - Typescript??? (darüber denkt KEGL gerade nach)
  - Visual Studio Code
  - Resharper
  - HeidiSQL
  - ...
  
## Gute Frage

  - Wie organisiert man den gesamten Tech Stack und alle geschriebenen Anwendungen so, dass ein Onboarder nach 1 Jahr in der Lage ist, alle Technologien durchschnittlich zu können und nach 2 Jahren Zertifikate darin ablegen könnte?
  
 
  

